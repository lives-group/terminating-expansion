module NPCF.Syntax.Properties where

-- open import Common.Type
-- open import Common.Context
-- open import Common.Name
-- open import Common.Depth using (Depth; ⇑; ⇓)
-- open import NPCF.Syntax
-- open import Relation.Nullary using (¬_)
-- open import Relation.Binary.PropositionalEquality using (_≡_; refl)
-- open import Data.Empty using (⊥-elim)
--
-- data _⦂_not-called-in_ : ∀{Γ τ} → Name → Type → Γ N⊢´ τ ⊚ ⇓ → Set where
--   no-call-err   : ∀{Γ v τ τ'} → v ⦂ τ not-called-in (err {Γ} {τ'})
--   no-call-zer   : ∀{Γ v τ} → v ⦂ τ not-called-in (zer {Γ})
--   no-call-varn  : ∀{Γ v₁ v₂ τ τ'}{t : v₂ ⦂ τ ∈ Γ} → ¬(v₁ ≡ v₂)
--                 → v₁ ⦂ τ' not-called-in (var v₂ t)
--   no-call-vart  : ∀{Γ v τ τ'}{t : v ⦂ τ ∈ Γ} → ¬(τ' ≡ τ)
--                 → v ⦂ τ' not-called-in (var v t)
--   no-call-suc   : ∀{Γ v τ'}{t : Γ N⊢´ nat ⊚ ⇓}
--                 → v ⦂ τ' not-called-in t → v ⦂ τ' not-called-in (suc t)
--   no-call-abs   : ∀{Γ v v' τ τ' τ₁}{t : Γ , v' ⦂ τ N⊢´ τ' ⊚ ⇓}
--                 → v ⦂ τ₁ not-called-in t → v ⦂ τ₁ not-called-in (abs v' t)
--   no-call-app   : ∀{Γ v τ τ' τ₁}{t : Γ N⊢´ τ ⇒ τ' ⊚ ⇓}{t' : Γ N⊢´ τ ⊚ ⇓}
--                 → v ⦂ τ₁ not-called-in t → v ⦂ τ₁ not-called-in t'
--                 → v ⦂ τ₁ not-called-in (app t t')
--   no-call-match : ∀{Γ v v' τ τ₁}{t : Γ N⊢´ nat ⊚ ⇓}{t₁ : Γ N⊢´ τ ⊚ ⇓}{t₂ : Γ , v' ⦂ nat N⊢´ τ ⊚ ⇓}
--                 → v ⦂ τ₁ not-called-in t → v ⦂ τ₁ not-called-in t₁ → v ⦂ τ₁ not-called-in t₂
--                 → v ⦂ τ₁ not-called-in (match t [z⇨ t₁ suc v' ⇨ t₂ ])
--
-- {-
-- Context substitution is useful for inlining
-- -}
-- context-substitution : ∀{Γ Δ τ ρ} → Γ ⊆ Δ → Γ N⊢´ τ ⊚ ρ → Δ N⊢´ τ ⊚ ρ
-- context-substitution p err = err
-- context-substitution p zer = zer
-- context-substitution p (suc t) = suc (context-substitution p t)
-- context-substitution p (var v x) = var v (∈-substitution p x)
-- context-substitution p (abs v t) = abs v (context-substitution (keep p) t)
-- context-substitution p (app t t₁) = app (context-substitution p t) (context-substitution p t₁)
-- context-substitution p match t [z⇨ t₁ suc v ⇨ t₂ ] = match context-substitution p t
--   [z⇨ context-substitution p t₁
--    suc v ⇨ context-substitution (keep p) t₂ ]
-- context-substitution p (let´ v ← t in´ t₁) = let´ v ← context-substitution p t in´ context-substitution (keep p) t₁
